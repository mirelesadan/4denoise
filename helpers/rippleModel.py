# -*- coding: utf-8 -*-
"""
Creating a model of a geometric surface "ripple." Useful for simulations of
rippled 2D materials, a common phenomenon in lateral heterojunctions of materials
involvings a significant lattice mismatch. 

Author: Adan J. Mireles
June 2024
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
from matplotlib.cm import ScalarMappable

def ripple(t=3.5, n=25., k=4.6, m=3, p=4.2, res=1, 
           show_ripple_data=True, crop_size=None, return_full_ripple=True):
    """
    Generates a symmetrical ripple pattern based on mathematical transformations.

    This function creates a ripple effect using trigonometric manipulations,
    where parameters control various aspects of the ripple's appearance such as
    width, sharpness, and edge characteristics. The ripple is symmetrically
    reflected to form a full pattern.

    Parameters
    ----------
    t : float
        Influences the width of each ripple along the x-axis. Higher 't' values
        result in wider ripples. Default is 3.5.
    n : float
        Controls the sharpness of the amplitude decrease in a direction parallel
        to the ripple. Higher 'n' results in a more rectangular ripple (as 
        viewed from the side). Default is 25.
    k : float
        Affects the widening of the ripple ends. Higher 'k' values result in wider
        ripple ends, while lower values result in no widening. Default is 4.6.
    m : int
        Influences the ripple's edges. In combination with 'p', it controls the
        rounding of the corners. 'm' is generally constant; default is 3.
    p : float
        Works with 'm' to influence the corners (roundness) of the ripple. 
        Recommended values are between 3 and 5. Default is 4.2.
    res : float
        Resolution factor that scales the overall size of the ripple pattern.
        Higher values produce a larger pattern. Default is 1, resulting in a (45,45) 2D array.
    crop_size : int, optional
        Number of pixels to crop from each edge of the pattern to 'zoom' into the center. 
        If None, no cropping is performed.
    show_ripple_data : bool
        If True, displays the ripple pattern, the tilt magnitude, and the (y, x) 
        components of the tilt using matplotlib. Default is True.

    Returns
    -------
    full_ripple : numpy.ndarray (float32)
        A 2D array representing the ripple pattern.

    Notes
    -----
    The ripple pattern is generated by first creating the right half of the ripple
    based on the given parameters, then mirroring it to create a full symmetrical pattern.
    The function uses numpy for calculations and matplotlib for optional visualization.
    """

     # Define the dimensions based on resolution
    n_px_half = round(45 * res / 2)
    ripple = np.zeros((n_px_half, n_px_half), dtype=np.float32)
    
    # Define the range for half of the ripple
    ys = np.linspace(0, 6, n_px_half)
    xs = np.linspace(0, 6, n_px_half)
    
    for y_idx, y in enumerate(ys):
        for x_idx, x in enumerate(xs):
            A = 1 / (1 + (np.abs(y) / k)**n)
            T = 1 + np.abs(y)**(2 * m) / 10**p
            H = A * (np.cos(np.pi * x / (t * T)))**2
            
            # Avoid ripple oscillations due to cosine function in model
            if x >= t * T / 2:
                break
            
            ripple[y_idx, x_idx] = H
    
    if return_full_ripple:
    
        ripple = complete_ripple(ripple)
    
    if crop_size is not None:
        # Ensure crop_size does not exceed half the smallest dimension of the full_ripple
        crop_size = min(crop_size, ripple.shape[0]//2, ripple.shape[1]//2)
        ripple = ripple[crop_size:-crop_size, crop_size:-crop_size]
    
    if show_ripple_data:
        
        plt.figure(figsize=(12, 10))

        # Ripple height
        ax1 = plt.subplot(2, 2, 1)
        cax1 = plt.imshow(ripple, cmap='turbo')
        plt.title('Ripple Height (px)')
        cb1 = plt.colorbar(cax1, ax=ax1)
        cb1.ax.set_title('Pixels', pad=10)

        # Calculate x and y tilts
        grad_0 = np.arctan(np.gradient(ripple)[0]) * 180 / np.pi
        grad_1 = np.arctan(np.gradient(ripple)[1]) * 180 / np.pi

        # Magnitude of the tilt
        ax2 = plt.subplot(2, 2, 2)
        cax2 = plt.imshow(np.sqrt(grad_0**2 + grad_1**2), cmap='gray')
        plt.title('Total Tilt')
        cb2 = plt.colorbar(cax2, ax=ax2)
        cb2.ax.set_title('Degrees', pad=10)

        # Tilt in x-direction
        ax3 = plt.subplot(2, 2, 3)
        cax3 = plt.imshow(grad_1, cmap='RdBu')
        plt.title('Tilt in X Direction')
        cb3 = plt.colorbar(cax3, ax=ax3)
        cb3.ax.set_title('Degrees', pad=10)

        # Tilt in y-direction
        ax4 = plt.subplot(2, 2, 4)
        cax4 = plt.imshow(grad_0, cmap='RdBu')
        plt.title('Tilt in Y Direction')
        cb4 = plt.colorbar(cax4, ax=ax4)
        cb4.ax.set_title('Degrees', pad=10)

        plt.tight_layout()
        plt.show()
    
    return ripple

def complete_ripple(ripple_bottom_right):
    
    # Create the top half by mirroring the quarter horizontally
    top_half = np.concatenate((np.fliplr(ripple_bottom_right), ripple_bottom_right), axis=1)
    
    # Create the full ripple by mirroring the top half vertically
    ripple = np.concatenate((np.flipud(top_half), top_half), axis=0)
    
    return ripple

def calculate_surface_tilt(surface, units='rad', show_results=True):
    """
    Calculate the tilt magnitude and tilt axis (gradient direction) of a surface and optionally display the results.

    Parameters
    ----------
    surface : numpy.ndarray
        A 2D array of height values representing the surface.
    units : str, optional
        The unit of the tilt magnitude and direction. Can be 'rad' for radians or 'deg' for degrees.
        Default is 'rad'.
    show_results : bool, optional
        If True, plots the tilt magnitude and direction. Default is True.

    Returns
    -------
    tilt_magnitude : numpy.ndarray
        A 2D array where each value represents the angular magnitude of the gradient (tilt magnitude),
        in specified units (either radians or degrees).
    tilt_direction : numpy.ndarray
        A 2D array where each value represents the direction of the gradient, in specified units
        (either radians or degrees).

    Examples
    --------
    >>> import numpy as np
    >>> surface = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> tilt_magnitude, tilt_direction = calculate_surface_tilt(surface, units='deg', show_results=True)

    Notes
    -----
    The tilt direction is calculated relative to the horizontal axis. Edge values for the tilt
    magnitude and direction are set based on the boundary conditions and may not accurately
    represent the actual tilt due to the lack of neighboring data.
    """
    
    # Compute gradients along x and y axes
    gy, gx = np.gradient(surface)
    
    # Calculate gradient magnitude and then calculate arctan of this magnitude
    gradient_magnitude = np.sqrt(gx**2 + gy**2)
    tilt_magnitude = np.arctan(gradient_magnitude)
    tilt_direction = np.arctan2(gy, gx) + np.pi
    
    # Convert tilt magnitude and direction to degrees if required
    if units == 'deg':
        tilt_magnitude = np.degrees(tilt_magnitude)
        tilt_direction = np.degrees(tilt_direction)
        unit_label = 'Degrees'
    else:
        unit_label = 'Radians'
    
    if show_results:
        plt.figure(figsize=(12, 6))

        # Tilt magnitude
        ax1 = plt.subplot(1, 2, 1)
        cax1 = plt.imshow(tilt_magnitude, cmap='gray')
        plt.title('Tilt Magnitude')
        cb1 = plt.colorbar(cax1, ax=ax1)
        cb1.ax.set_title(unit_label, pad=10)

        # Tilt direction
        ax2 = plt.subplot(1, 2, 2)
        cax2 = plt.imshow(tilt_direction, cmap='hsv')
        plt.title('Tilt Direction')
        cb2 = plt.colorbar(cax2, ax=ax2)
        cb2.ax.set_title(unit_label, pad=10)

        plt.tight_layout()
        plt.show()
    
    return tilt_magnitude, tilt_direction


def phplot(field1, Amp='raw', scale=True, subplot=True):
    """
    Visualize the phase and amplitude of a field as an RGB image and optionally display a color wheel.

    Parameters
    ----------
    field1 : complex ndarray or tuple
        The input field. Can be a complex array or a tuple of (phase, magnitude).
    Amp : str, optional
        Control for amplitude visualization:
        'uniform' - use a uniform amplitude across the image,
        'log' - use logarithmic scaling of the amplitude,
        'raw' - use the raw amplitude values.
    scale : bool, optional
        If True, plots a color wheel with corresponding phase hues. Default is False.
    subplot : bool, optional
        If True, uses subplots to show the image and color wheel; otherwise, separate figures.

    Returns
    -------
    rgb_image : ndarray
        An array representing the RGB visualization of the input field.
    
    Notes
    -----
    This code is based on the MATLAB code written by [author] in [date].
    """
    
    if isinstance(field1, tuple):
        phase, amplitude = field1
    else:
        phase = np.angle(field1)
        amplitude = np.abs(field1)
    
    # Normalize amplitude
    amplitude = amplitude/np.max(amplitude)
    
    if Amp == 'uniform':
        amplitude = np.ones_like(amplitude)
    elif Amp == 'log':
        min_amplitude = np.min(amplitude[amplitude > 0])
        amplitude = np.log(amplitude / min_amplitude) / np.log(amplitude.max())
    elif Amp != 'raw':
        raise ValueError("Amp must be 'uniform', 'log', or 'raw'.")

    # Create RGB image
    rgb_image = np.zeros((*amplitude.shape, 3))
    rgb_image[..., 0] = 0.5 * (np.sin(phase) + 1) * amplitude  # Red
    rgb_image[..., 1] = 0.5 * (np.sin(phase + np.pi / 2) + 1) * amplitude  # Green
    rgb_image[..., 2] = 0.5 * (-np.sin(phase) + 1) * amplitude  # Blue

    if not subplot:
        plt.figure(figsize=(10, 10))
        plt.axis('off')
        plt.imshow(rgb_image)
        plt.show()
    
    if scale:
        # Color wheel
        phase = np.linspace(0, 2 * np.pi, 256)
        r = 0.5 * (np.sin(phase) + 1)
        g = 0.5 * (np.sin(phase + np.pi / 2) + 1)
        b = 0.5 * (-np.sin(phase) + 1)
        colorwheel = np.stack([r, g, b], axis=1)
        warphase = ListedColormap(colorwheel)

        x, y = np.meshgrid(np.linspace(-1, 1, 256), np.linspace(-1, 1, 256))
        z = x + 1j * y
        mask = x**2 + y**2 > 1
        z[mask] = np.nan

        hue = np.angle(z)     
        idx = np.clip(((hue + np.pi) / (2 * np.pi) * 255).astype(int), 0, 255)
        color_wheel = colorwheel[idx]
        color_wheel = (color_wheel.T * np.abs(z)).T
        color_wheel = np.rot90(color_wheel, 2)
        color_wheel[np.isnan(color_wheel)] = 1.0

        if subplot:
            plt.figure(figsize=(12, 6))  # Increase the figure size for better visibility
            plt.subplot(1, 2, 1)
            plt.imshow(rgb_image)
            # plt.title("RGB Image of Field")
            plt.axis('off')
            plt.subplot(1, 2, 2)
            plt.imshow(color_wheel, origin='lower')
            # plt.title("Color Wheel")
            plt.axis('off')
            sm = ScalarMappable(cmap=warphase)
            sm.set_array([])
            # cbar = plt.colorbar(sm, orientation='vertical', ticks=[0, 0.25, 0.5, 0.75, 1])
            cbar = plt.colorbar(sm, orientation='vertical', ticks=[0, 0.25, 0.5, 0.75, 1], fraction=0.046, pad=0.04)  # Adjusted size
            cbar.set_label('Hue', rotation=270, labelpad=15)
            cbar.set_ticklabels(["0", "π/2", "π", "3π/2", "2π"])
            plt.tight_layout()
            plt.show()
        else:
            plt.figure(figsize=(10, 10))
            plt.imshow(color_wheel, origin='lower')
            plt.axis('off')
            plt.show()

    return rgb_image